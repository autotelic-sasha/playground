<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JSON Schema Dependency Tree</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root{
      --bg:#0b1220; --panel:#11182a; --panel2:#0f1a2e;
      --border:#1e2a43; --text:#e6edf7; --muted:#93a4bd;
      --btn:#132036; --btnBorder:#28405d; --btnHover:#3a5f8a;
      --accent:#8fd3ff;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
    .app{display:grid; grid-template-rows:auto 1fr; height:100%;}
    header{display:flex; flex-wrap:wrap; align-items:center; gap:10px;
      padding:10px 12px; background:var(--panel); border-bottom:1px solid var(--border);}
    header h1{margin:0 10px 0 0; font-size:15px; font-weight:650; color:#cfe6ff;}
    .btn{appearance:none; border:1px solid var(--btnBorder); background:var(--btn); color:var(--text);
      padding:8px 10px; border-radius:10px; cursor:pointer; font-size:12px;}
    .btn:hover{border-color:var(--btnHover);}
    .pill{display:inline-flex; gap:8px; align-items:center; background:#0e1a2e;
      border:1px solid #283d5a; padding:6px 10px; border-radius:999px; font-size:12px; color:var(--muted);}
    .pill input{margin:0;}
    .hidden{display:none;}
    .status{margin-left:auto; font-size:12px; color:var(--muted);}
    #main{display:grid; grid-template-columns: 1.3fr 1fr; height:100%;}
    #chartWrap{position:relative; border-right:1px solid var(--border);}
    #chart{height:100%; width:100%;}
    #details{height:100%; overflow:auto; background:var(--panel2);}
    #detailsHeader{position:sticky; top:0; background:var(--panel2); border-bottom:1px solid var(--border);
      padding:10px 12px; display:flex; gap:10px; align-items:center;}
    #detailsHeader h2{margin:0; font-size:14px; color:#cfe6ff; font-weight:650;}
    #search{flex:1; min-width:140px; background:#0e1a2e; border:1px solid #283d5a; color:var(--text);
      border-radius:10px; padding:8px 10px; font-size:12px;}
    #detailsBody{padding:10px 12px;}
    .meta{font-size:12px; color:var(--muted); margin:6px 0 10px;}
    .kbd{background:#0b1324; border:1px solid #213352; border-radius:7px; padding:2px 6px;
      font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:11px; color:#cfe6ff;}
    details{border:1px solid #213352; border-radius:12px; margin:8px 0; overflow:hidden;}
    summary{cursor:pointer; padding:8px 10px; background:#0e1a2e; color:#cfe6ff; font-weight:600; font-size:12px;}
    .node{padding:8px 10px;}
    .row{display:grid; grid-template-columns: 220px 1fr; gap:10px; padding:4px 0; border-bottom:1px dashed #213352;}
    .row:last-child{border-bottom:none;}
    .k{color:#9fb3cc; font-size:12px; word-break:break-word;}
    .v{font-size:12px; color:var(--text); word-break:break-word; white-space:pre-wrap;}
    .tag{display:inline-block; padding:2px 8px; border-radius:999px; background:#13293f; border:1px solid #28405d;
      font-size:11px; color:#cfe6ff; margin-right:6px;}
    .hint{font-size:12px; color:var(--muted); padding:10px 12px;}
  </style>
</head>
<body>
<div class="app">
  <header>
    <h1>JSON Schema dependency tree</h1>

    <label class="btn" for="folder">üìÅ Load folder</label>
    <input id="folder" type="file" webkitdirectory directory multiple class="hidden" />

    <button id="sample" class="btn">Load sample</button>

    <span class="pill"><input id="toggleExternal" type="checkbox"><label for="toggleExternal">show external refs</label></span>

    <div class="status" id="status">No data loaded.</div>
  </header>

  <div id="main">
    <div id="chartWrap">
      <div id="chart"></div>
    </div>

    <div id="details">
      <div id="detailsHeader">
        <h2 id="detailsTitle">Details</h2>
        <input id="search" type="text" placeholder="Filter keys (e.g. properties, $ref, title)..." />
      </div>
      <div class="hint" id="detailsHint">Click a node in the tree to view the full schema data here.</div>
      <div id="detailsBody" class="hidden"></div>
    </div>
  </div>
</div>

<script>
// ---------- Helpers ---------------------------------------------------------
function baseNameNoExt(path){
  const base = (path || '').split('/').pop() || path || '';
  return base.replace(/\.[^.]+$/, '');
}
function folderOf(path){
  const parts = (path || '').split('/');
  return parts.length > 1 ? parts.slice(0, -1).join('/') : '(root)';
}
function normalizeRel(fromPath, rel){
  const fromParts = (fromPath.split('/').slice(0,-1));
  const relParts = rel.split('/');
  const base = [...fromParts];
  for (const part of relParts){
    if (!part || part === '.') continue;
    if (part === '..') base.pop();
    else base.push(part);
  }
  return base.join('/');
}
function refParts(ref){
  if (!ref) return [null,null];
  if (ref.startsWith('#')) return [null, ref];
  const i = ref.indexOf('#');
  if (i === -1) return [ref, null];
  return [ref.slice(0,i), '#' + ref.slice(i+1)];
}
function resolvePointer(obj, pointer){
  if (!pointer || pointer === '#') return obj;
  const path = pointer.replace(/^#\//, '').split('/').map(s=>s.replace(/~1/g,'/').replace(/~0/g,'~'));
  let cur = obj;
  for (const key of path){
    if (cur && typeof cur === 'object' && key in cur) cur = cur[key];
    else throw new Error('Bad pointer ' + pointer);
  }
  return cur;
}
function escapeHtml(str){
  const map = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};
  return String(str).replace(/[&<>"']/g, s => map[s]);
}
function hashToColor(str){
  // stable hash -> palette index
  const palette = [
    '#4E79A7','#59A14F','#9C755F','#F28E2B','#EDC948','#B07AA1','#FF9DA7','#76B7B2','#E15759','#BAB0AC'
  ];
  let h = 2166136261;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return palette[Math.abs(h) % palette.length];
}
function isObject(x){ return x && typeof x === 'object' && !Array.isArray(x); }

// ---------- Extract refs from schema JSON -----------------------------------
function collectRefs(obj, out){
  if (!obj || typeof obj !== 'object') return;
  if (Array.isArray(obj)){
    for (const it of obj) collectRefs(it, out);
    return;
  }
  // object
  if (typeof obj.$ref === 'string') out.push(obj.$ref);
  for (const v of Object.values(obj)){
    collectRefs(v, out);
  }
}

// ---------- Build file graph & tree ----------------------------------------
async function loadFiles(fileList){
  const files = [...fileList].filter(f => f.name.toLowerCase().endsWith('.json'));
  const docs = new Map();     // relpath -> parsed json
  const idIndex = new Map();  // $id -> relpath OR doc; we use relpath if possible
  for (const f of files){
    try{
      const txt = await f.text();
      const obj = JSON.parse(txt);
      const key = f.webkitRelativePath || f.name;
      docs.set(key, obj);
      if (obj && typeof obj === 'object' && typeof obj.$id === 'string'){
        idIndex.set(obj.$id, key);
      }
    }catch(e){
      console.warn('Failed to parse', f.name, e);
    }
  }
  if (docs.size === 0) throw new Error('No .json files found');
  return {docs, idIndex};
}

function resolveRefToFile(fromPath, refStr, docs, idIndex){
  const [filePart, frag] = refParts(refStr);
  if (!filePart) return { path: fromPath, ptr: frag || '#', external:false };
  // $id
  if (idIndex.has(filePart)) return { path: idIndex.get(filePart), ptr: frag || '#', external:false };
  // relative
  const targetRel = normalizeRel(fromPath, filePart);
  if (docs.has(targetRel)) return { path: targetRel, ptr: frag || '#', external:false };
  // maybe already root-relative
  if (docs.has(filePart)) return { path: filePart, ptr: frag || '#', external:false };
  // external
  return { path: filePart, ptr: frag || '#', external:true };
}

function buildGraph(docs, idIndex, showExternal){
  const outgoing = new Map(); // file -> Set(child file or external key)
  const incoming = new Map(); // file -> count

  for (const [path, doc] of docs.entries()){
    outgoing.set(path, new Set());
    incoming.set(path, 0);
  }

  for (const [path, doc] of docs.entries()){
    const refs = [];
    collectRefs(doc, refs);
    for (const r of refs){
      const res = resolveRefToFile(path, r, docs, idIndex);
      if (res.external){
        if (showExternal) outgoing.get(path).add('EXTERNAL::' + res.path);
      } else if (docs.has(res.path)){
        outgoing.get(path).add(res.path);
      }
    }
  }

  // incoming counts (only for internal)
  for (const [from, tos] of outgoing.entries()){
    for (const to of tos){
      if (to.startsWith('EXTERNAL::')) continue;
      incoming.set(to, (incoming.get(to) || 0) + 1);
    }
  }

  return {outgoing, incoming};
}

function buildForestTree(docs, outgoing, incoming){
  // roots are files with no incoming edges
  const roots = [];
  for (const [file, count] of incoming.entries()){
    if ((count || 0) === 0) roots.push(file);
  }
  // if everything has incoming (cycle), just include all files as roots
  if (roots.length === 0){
    roots.push(...docs.keys());
  }

  const externalNodes = new Map(); // EXTERNAL::x -> node
  function makeExternalNode(key){
    if (externalNodes.has(key)) return externalNodes.get(key);
    const label = key.replace(/^EXTERNAL::/, '');
    const node = {
      name: baseNameNoExt(label) || label,
      filePath: key,
      kind: 'external',
      folder: '(external)',
      itemStyle: { color: '#2b4367', borderColor:'#2b4367' },
      children: []
    };
    externalNodes.set(key, node);
    return node;
  }

  function makeNode(file, stack){
    const name = baseNameNoExt(file) || file;
    const folder = folderOf(file);
    const color = hashToColor(folder);
    const node = {
      name,
      filePath: file,
      kind: 'file',
      folder,
      value: { filePath: file, folder },
      itemStyle: { color, borderColor: color },
      lineStyle: { color: '#2b4367' },
      children: []
    };

    const kids = outgoing.get(file) ? [...outgoing.get(file)] : [];
    for (const k of kids){
      if (k.startsWith('EXTERNAL::')){
        node.children.push(makeExternalNode(k));
        continue;
      }
      if (stack.includes(k)){
        // cycle marker
        node.children.push({
          name: baseNameNoExt(k) + ' ‚Ü©',
          filePath: k,
          kind: 'cycle',
          folder: folderOf(k),
          itemStyle: { color: '#7a5c2e', borderColor:'#7a5c2e' },
          children: []
        });
        continue;
      }
      node.children.push(makeNode(k, stack.concat([k])));
    }
    return node;
  }

  const root = {
    name: 'Schemas',
    filePath: '__ROOT__',
    kind: 'root',
    itemStyle: { color: '#132036', borderColor:'#28405d' },
    children: roots.map(r => makeNode(r, [r]))
  };
  return root;
}

// ---------- UI: details panel ----------------------------------------------
let CURRENT_DOCS = null;

function renderValue(key, val, filter){
  const kMatch = !filter || String(key).toLowerCase().includes(filter);
  const vMatch = !filter || (typeof val === 'string' && val.toLowerCase().includes(filter));
  if (filter && !(kMatch || vMatch)) {
    // for objects/arrays we still want to keep if any nested matches
    if (val && typeof val === 'object') {
      const inner = renderJson(val, filter);
      if (inner.trim() === '') return '';
      return `<details open><summary>${escapeHtml(String(key))}</summary><div class="node">${inner}</div></details>`;
    }
    return '';
  }

  if (val === null || val === undefined){
    return `<div class="row"><div class="k">${escapeHtml(String(key))}</div><div class="v"><span class="tag">null</span></div></div>`;
  }
  if (Array.isArray(val)){
    const inner = val.map((it, idx) => renderValue(idx, it, filter)).join('');
    return `<details><summary>${escapeHtml(String(key))} <span class="tag">array</span> <span class="tag">${val.length}</span></summary><div class="node">${inner || '<div class="meta">(empty)</div>'}</div></details>`;
  }
  if (isObject(val)){
    const inner = renderJson(val, filter);
    return `<details><summary>${escapeHtml(String(key))} <span class="tag">object</span></summary><div class="node">${inner || '<div class="meta">(empty)</div>'}</div></details>`;
  }
  const tag = typeof val;
  return `<div class="row"><div class="k">${escapeHtml(String(key))}</div><div class="v"><span class="tag">${escapeHtml(tag)}</span> ${escapeHtml(String(val))}</div></div>`;
}

function renderJson(obj, filter){
  if (!obj || typeof obj !== 'object') return '';
  if (Array.isArray(obj)){
    return obj.map((it, idx) => renderValue(idx, it, filter)).join('');
  }
  return Object.entries(obj).map(([k,v]) => renderValue(k, v, filter)).join('');
}

function showDetails(filePath, schemaObj){
  document.getElementById('detailsHint').classList.add('hidden');
  const body = document.getElementById('detailsBody');
  body.classList.remove('hidden');

  const title = document.getElementById('detailsTitle');
  const folder = folderOf(filePath);
  title.textContent = baseNameNoExt(filePath) || 'Details';

  const filter = (document.getElementById('search').value || '').trim().toLowerCase();
  const headerMeta = `
    <div class="meta">
      <span class="kbd">${escapeHtml(filePath)}</span>
      <span style="margin-left:8px;" class="tag">${escapeHtml(folder)}</span>
    </div>
  `;

  body.innerHTML = headerMeta + renderJson(schemaObj, filter);
}

// ---------- ECharts tree ----------------------------------------------------
let chart = null;
function renderTree(rootNode){
  const el = document.getElementById('chart');
  if (!chart) chart = echarts.init(el, null, {renderer:'canvas'});
  const option = {
    backgroundColor: 'transparent',
    tooltip: {
      trigger: 'item',
      triggerOn: 'mousemove',
      formatter: (p) => {
        const d = p.data || {};
        if (d.kind === 'root') return 'Schemas';
        if (d.kind === 'external') return `<b>External</b><br/>${escapeHtml(String(d.filePath || '').replace(/^EXTERNAL::/, ''))}`;
        const fp = d.filePath || '';
        const fol = d.folder || folderOf(fp);
        return `<b>${escapeHtml(d.name || '')}</b><br/><span style="color:#9fb3cc">${escapeHtml(fol)}</span><br/><span style="color:#93a4bd">${escapeHtml(fp)}</span>`;
      }
    },
    toolbox: {
      right: 10,
      top: 10,
      iconStyle: { borderColor: '#93a4bd' },
      feature: {
        saveAsImage: { title: 'Save', backgroundColor: '#0b1220' },
        restore: { title: 'Reset' }
      }
    },
    series: [{
      type: 'tree',
      data: [rootNode],
      top: '2%',
      left: '2%',
      bottom: '2%',
      right: '2%',
      symbol: 'roundRect',
      symbolSize: [160, 28],
      orient: 'LR',
      layout: 'orthogonal',
      roam: true,
      expandAndCollapse: true,
      initialTreeDepth: 1,
      animationDuration: 350,
      animationDurationUpdate: 450,
      label: {
        position: 'inside',
        align: 'center',
        verticalAlign: 'middle',
        color: '#e6edf7',
        fontSize: 12,
        formatter: (p) => p.data && p.data.name ? p.data.name : ''
      },
      leaves: {
        label: { position: 'inside', color:'#e6edf7' }
      },
      lineStyle: {
        color: '#2b4367',
        width: 1.3,
        curveness: 0
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        focus: 'descendant'
      }
    }]
  };
  chart.setOption(option, true);

  chart.off('click');
  chart.on('click', (params) => {
    const d = params.data || {};
    if (d.kind === 'file' && CURRENT_DOCS && CURRENT_DOCS.docs.has(d.filePath)){
      showDetails(d.filePath, CURRENT_DOCS.docs.get(d.filePath));
      document.getElementById('status').textContent = `Selected: ${d.filePath}`;
    } else if (d.kind === 'cycle' && CURRENT_DOCS && CURRENT_DOCS.docs.has(d.filePath)){
      showDetails(d.filePath, CURRENT_DOCS.docs.get(d.filePath));
      document.getElementById('status').textContent = `Cycle reference: ${d.filePath}`;
    } else if (d.kind === 'external'){
      document.getElementById('status').textContent = `External reference: ${String(d.filePath).replace(/^EXTERNAL::/, '')}`;
    }
  });

  window.addEventListener('resize', () => chart && chart.resize());
}

// ---------- Sample ----------------------------------------------------------
const SAMPLE = {
  "pkgA/user.json": { "$id":"user.json", "title":"User", "type":"object", "properties": {
    "id": { "$ref":"types.json#/$defs/Id" },
    "name": { "type":"string" },
    "address": { "$ref":"../pkgB/address.json#" },
    "tags": { "type":"array", "items": { "$ref":"types.json#/$defs/Tag" } }
  }},
  "pkgB/address.json": { "$id":"address.json", "title":"Address", "type":"object", "properties":{
    "street": { "type":"string" },
    "city": { "type":"string" },
    "country": { "$ref":"types.json#/$defs/CountryCode" }
  }},
  "pkgA/types.json": { "$id":"types.json", "$defs": {
    "Id": { "type":"string" },
    "Tag": { "type":"string" },
    "CountryCode": { "type":"string", "enum":["US","IE","DE"] }
  }}
};

async function loadSample(){
  const docs = new Map(Object.entries(SAMPLE));
  const idIndex = new Map();
  for (const [k,v] of docs.entries()){
    if (v && typeof v === 'object' && typeof v.$id === 'string') idIndex.set(v.$id, k);
  }
  CURRENT_DOCS = {docs, idIndex};
  const showExternal = document.getElementById('toggleExternal').checked;
  const g = buildGraph(docs, idIndex, showExternal);
  const root = buildForestTree(docs, g.outgoing, g.incoming);
  renderTree(root);
  document.getElementById('status').textContent = `Sample loaded: ${docs.size} files`;
}

// ---------- Wiring ----------------------------------------------------------
document.getElementById('sample').onclick = loadSample;

document.getElementById('folder').addEventListener('change', async (e) => {
  try{
    const {docs, idIndex} = await loadFiles(e.target.files);
    CURRENT_DOCS = {docs, idIndex};
    const showExternal = document.getElementById('toggleExternal').checked;
    const g = buildGraph(docs, idIndex, showExternal);
    const root = buildForestTree(docs, g.outgoing, g.incoming);
    renderTree(root);
    document.getElementById('status').textContent = `Loaded: ${docs.size} files`;
  }catch(err){
    alert(err.message);
  }
});

document.getElementById('toggleExternal').addEventListener('change', () => {
  if (!CURRENT_DOCS) return;
  const showExternal = document.getElementById('toggleExternal').checked;
  const g = buildGraph(CURRENT_DOCS.docs, CURRENT_DOCS.idIndex, showExternal);
  const root = buildForestTree(CURRENT_DOCS.docs, g.outgoing, g.incoming);
  renderTree(root);
});

document.getElementById('search').addEventListener('input', () => {
  // re-render details for current selection if any
  const title = document.getElementById('detailsTitle').textContent || '';
  if (!CURRENT_DOCS) return;
  // Try to find selected by status prefix (best-effort)
  const status = document.getElementById('status').textContent || '';
  const m = status.match(/Selected:\s(.+)/);
  if (m && m[1] && CURRENT_DOCS.docs.has(m[1])) {
    showDetails(m[1], CURRENT_DOCS.docs.get(m[1]));
  }
});

// initial hint
document.getElementById('status').textContent = 'Click ‚ÄúLoad folder‚Äù to build a left-to-right dependency tree.';
</script>
</body>
</html>
